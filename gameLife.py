#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  gameLife.py
#  Generated by Geany 1.22
#  
#  Author:	Edward Osorio S.
#  Date:	2015-12-22
#  Version:	1.0
#  Mail:	osorio.edd@gmail.com
#  
#  Copyright 2015
#  

# El juego de la vida
# Si un cuadrado esta rodeado por 3 celulas vecinas, entonces se crea vida, agregando una celula a ese sitio
# Si una celula esta rodeada por menos de 2 celulas vecinas, muere por aislamiento y la casilla de la grilla 
# correspondiente queda vacia, y si tiene mas de 3 celulas vecinas, muere por sofocacion y tambien se libera
# el cuadrado de la grilla que le correspondia
# Una celula que tiene exactamente 2 o 3 vecinas sobrevive una instancia mas en el juego
# 

import random as rnd
import os
import time
rnd.seed()

class Game:
	_cell = '+'
	_noCell = ' '
	_xElements = 20
	_yElements = 30
	_helpedGrid = []
	_grid = []
	# _grid = [
	# 	# 1	   2    3    4    5    6    7    8    9	  10   11   12   13   14   15   16   17   18   19   20
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  1
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  2
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  3
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  4
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  5
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  6
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  7
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  8
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '+', '+', '+', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	#  9
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '+', ' ', ' ', '+', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 10
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 11
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 12
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 13
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 14
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 15
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 16
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 17
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 18
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 19
	# 	[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],	# 20
	# ]

	def addRndCell(self):
		if (rnd.randint(0,999)*2.6) % 2 == 0 :
			return True
		else:
			return False

	def createInitialGrid(self):
		self._grid = []
		for x in range(0, self._xElements):
			tmpX = []
			for y in range(0, self._yElements):
				if self.addRndCell():
					tmpX.append(self._cell)
				else:
					tmpX.append(self._noCell)
			self._grid.append(tmpX)

		self.drawGrid(self._grid)

	def isCell(self, element):
		if element == self._cell:
			return True
		else:
			return False

	def checkNeighborns(self, indexX, indexY):
		_nCells = 0
		for x in [-1,0,1]:
			for y in [-1,0,1]:
				if ((indexX + x) in range(0, self._xElements)) and ((indexY + y) in range(0, self._yElements)):
					_tmp = self._grid[indexX + x][indexY + y]
					if self.isCell( _tmp ):
						_nCells+=1

		if self.isCell( self._grid[indexX][indexY] ):
			_nCells-=1

		return _nCells

	def checkGrid(self):
		self._helpedGrid = []
		_i = 0
		for x in self._grid:
			tmpX = []
			_j = 0
			for e in x:
				nCells = self.checkNeighborns(_i, _j)
				tmpX.append(str(nCells))
				_j+=1

			self._helpedGrid.append(tmpX)
			_i+=1

		#self.drawGrid(self._helpedGrid)

	def recreateGrid(self):
		for x in range(0, self._xElements):
			for y in range(0, self._yElements):
				if (not self.isCell( self._grid[x][y] )) and (int(self._helpedGrid[x][y]) == 3):
					self._grid[x][y] = self._cell
					continue

				if self.isCell( self._grid[x][y] ) and (int(self._helpedGrid[x][y]) < 2):
					self._grid[x][y] = self._noCell
					continue

				if self.isCell( self._grid[x][y] ) and (int(self._helpedGrid[x][y]) > 3):
					self._grid[x][y] = self._noCell
					continue

		self.drawGrid(self._grid)

	#def createHelpedGrid(self):
		#self._helpedGrid = []
		#_i = 0
		#for x in self._grid:
			#tmpX = []
			#_j = 0
			#for e in x:
				#if (_i==0 and _j==0) or (_j==(len(x)-1) and _i==(len(self._grid)-1)) or (_i==0 and _j==(len(x)-1)) or (_i==(len(self._grid)-1) and _j==0):
					#tmpX.append('A')
					#_j+=1
					#continue

				#if (_i==0 and _j!=0) or (_i!=0 and _j==0) or (_i==(len(self._grid)-1) and _j!=0) or (_i!=0 and _j==(len(x)-1)):
					#tmpX.append('O')
					#_j+=1
					#continue

				#tmpX.append('I')
				#_j+=1

			#self._helpedGrid.append(tmpX)
			#_i+=1

		#self.drawGrid(self._helpedGrid)

	def drawGrid(self, grid):
		for x in grid:
			print(' '.join(x))

	def play(self):
		if len(self._grid) <= 0:
			self.createInitialGrid()
		else:
			self._xElements = len(self._grid)
			self._yElements = len(self._grid[0])
			self.drawGrid(self._grid)

		lastGrid = self._helpedGrid
		for x in range(0,100):
			time.sleep(0.5)
			# os.system('clear')
			os.system('cls')
			self.checkGrid()
			self.recreateGrid()
			if lastGrid == self._helpedGrid:
				break
			else:
				lastGrid = self._helpedGrid

def main():
	game = Game()
	game.play()

	return 0

if __name__ == '__main__':
	main()

